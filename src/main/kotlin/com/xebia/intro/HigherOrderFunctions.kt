package com.xebia.com.xebia.intro

import java.text.NumberFormat
import java.time.LocalDate
import java.util.*
import kotlin.random.Random

/**
 * Functional programming revolves around using functions as the primary building blocks for constructing software.
 * It promotes breaking down business logic into smaller, pure functions, each performing a single task. These smaller
 * functions can be easily combined and composed to build more complex operations, promoting code reuse and modularity.
 * This approach enhances code clarity and maintainability and simplifies the process of verifying correctness through
 * unit testing.
 */

enum class Genre {
    Rock, Pop, Jazz
}

data class Artist(val name: String, val feePerSongPlayed: Double)

data class Song(val title: String, val artist: Artist, val genre: Genre, val releaseDate: LocalDate)

/**
 * Value class that represents a data source with stats about song plays
 */
@JvmInline
value class PlayStats(val stats: Map<Song, Int>)

/**
 * Helper functions to generate dummy data
 */
fun generateSongsLibrary(): List<Song> {
    val artist1 = Artist(name = "Foo Fighters", feePerSongPlayed = 2500.0)
    val artist2 = Artist(name = "Taylor Swift", feePerSongPlayed = 3000.0)
    val artist3 = Artist(name = "The Black Keys", feePerSongPlayed = 2300.0)
    val artist4 = Artist(name = "Arctic Monkeys", feePerSongPlayed = 2400.0)
    val artist5 = Artist(name = "Billie Eilish", feePerSongPlayed = 2200.0)
    val artist6 = Artist(name = "The Weeknd", feePerSongPlayed = 2800.0)

    val song1 = Song(
        title = "Shame Shame",
        artist = artist1,
        genre = Genre.Rock,
        releaseDate = LocalDate.of(2020, 11, 7)
    )

    val song2 = Song(
        title = "Anti-Hero",
        artist = artist2,
        genre = Genre.Pop,
        releaseDate = LocalDate.of(2022, 10, 21)
    )

    val song3 = Song(
        title = "Lo/Hi",
        artist = artist3,
        genre = Genre.Rock,
        releaseDate = LocalDate.of(2019, 3, 7)
    )

    val song4 = Song(
        title = "Tranquility Base Hotel & Casino",
        artist = artist4,
        genre = Genre.Rock,
        releaseDate = LocalDate.of(2018, 5, 11)
    )

    val song5 = Song(
        title = "Bad Guy",
        artist = artist5,
        genre = Genre.Pop,
        releaseDate = LocalDate.of(2019, 3, 29)
    )

    val song6 = Song(
        title = "Blinding Lights",
        artist = artist6,
        genre = Genre.Pop,
        releaseDate = LocalDate.of(2019, 11, 29)
    )

    return listOf(song1, song2, song3, song4, song5, song6)
}

fun List<Song>.generatePlayStats(): PlayStats =
    associateWith {
        val playCount = Random.nextInt(100, 1000) // Simulate a call to an external service
        playCount
    }.let(::PlayStats)

/**
 * Step 1:
 * Implement an extension function for [Song] that checks if the song was released in the given year and belongs
 * to the specified musical genre
 */
fun Song.belongsToGenreAndReleasedInYear(selectedGenre: Genre, year: Int): Boolean =
    genre == selectedGenre && releaseDate.year == year

/**
 * Step 2:
 * Implement a function that calculates the royalties generated by a [Song] based on its [PlayStats]. If the song
 * does not have play stats, the function should return 0.0.
 */
fun PlayStats.calculateRoyalties(song: Song): Double {
    val playCount = stats[song] // Simulate a call to an external service
    return playCount?.let { it * song.artist.feePerSongPlayed } ?: 0.0
}

/**
 * Implement a function aggregating all the royalties generated by songs meeting the specified criteria. To solve
 * this exercise, use the appropriate higher-order function for:
 *   1. Filter the data source to extract only those songs that meet the criteria
 *   2. Transform the collection by calculating the royalty generated by each song
 *   3. Aggregate all the royalties to obtain a single final result
 */
fun aggregateRoyaltiesByUsingHigherOrderFunctions(songsLibrary: List<Song>, playStats: PlayStats, genre: Genre, year: Int) =
    songsLibrary
        .filter { it.belongsToGenreAndReleasedInYear(genre, year) }
        .map { playStats.calculateRoyalties(it) }
        .fold(0.0) { a, b -> a + b }

/**
 * The above implementation requires iterating the collection three times, which could be inefficient for
 * larger collections. Fortunately, Kotlin provides a function called [sumOf] that helps us obtain the result
 * in just one iteration. Adapt the code to use the mentioned function.
 */
fun aggregateRoyaltiesInOneIteration(songsLibrary: List<Song>, playStats: PlayStats, genre: Genre, year: Int) =
    songsLibrary
        .sumOf { song ->
            if (song.belongsToGenreAndReleasedInYear(genre, year))
                playStats.calculateRoyalties(song)
            else 0.0
        }

fun main() {
    val songsLibrary: List<Song> = generateSongsLibrary()
    val playStats: PlayStats = songsLibrary.generatePlayStats()
    val selectedGenre = Genre.Pop
    val selectedYear = 2019

    var royalty = 0.0
    for (song in songsLibrary) {
        if (song.belongsToGenreAndReleasedInYear(Genre.Pop, 2019)) {
            royalty += playStats.calculateRoyalties(song)
        }
    }

    val royaltiesByUsingHigherOrderFunctions = aggregateRoyaltiesByUsingHigherOrderFunctions(songsLibrary, playStats, selectedGenre, selectedYear)
    val royaltiesInOneRun = aggregateRoyaltiesInOneIteration(songsLibrary, playStats, selectedGenre, selectedYear)

    val currencyFormatter = NumberFormat.getCurrencyInstance()
    currencyFormatter.setMaximumFractionDigits(0)
    currencyFormatter.currency = Currency.getInstance("EUR")

    assert(royalty == royaltiesByUsingHigherOrderFunctions)
    assert(royalty == royaltiesInOneRun)

    println("In $selectedYear, ${selectedGenre.toString().lowercase()} songs generated ${currencyFormatter.format(royalty)} in royalties.")
}